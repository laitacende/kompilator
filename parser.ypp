%{
    #include <iostream>
    #include <string>
    #include <memory>
    #include <fstream>

    #include "./inc/IOOperations.hpp"
    #include "./inc/CodeGenerator.hpp"
    #include "./inc/Symbol.hpp"

    extern int yylineno;
    extern int yylex();
    extern FILE *yyin;

    int yyerror(std::string s);

    std::shared_ptr<MemoryData> dataController = std::make_shared<MemoryData>();
    std::shared_ptr<CodeGenerator> codeGen = std::make_shared<CodeGenerator>(dataController);

    std::vector<std::string> newSet;
    bool error = false;
%}

%union types {
    std::string* pidentifier;
    long long int num;
    Variable* var;
}

%start program
%token BEGIN_ /* conflict with macro BEGIN in flex */
%token END
%token VAR
%token WRITE
%token ASSIGN
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token <num> num
%token <pidentifier> pidentifier

%type <var> value
%type <var> identifier
%type <var> expression

%%

program:    VAR declarations BEGIN_ commands END
            | BEGIN_ commands END

declarations: declarations',' pidentifier { Variable* v = codeGen->allocateVariable(*$3);
                                             if (nullptr == v) {
                                                error = true;
                                                yyerror("Redefinition of variable " + *$3);
                                             }
                                            }
              | pidentifier     { Variable* v = codeGen->allocateVariable(*$1);
                                    if (nullptr == v && !error) {
                                        error = true;
                                        yyerror("Redeclaration of variable " + *$1);
                                    }
                                }

commands:   commands command
            | command

command:    WRITE value';' { if (!codeGen->write($2) && !error) {
                                error = true;
                                yyerror("Variable " + $2->name +" is not initialized");
                              }
                            }
            | identifier ASSIGN expression';' {  codeGen->assignToVariable($1, $3); }

expression: value /* TODO trzeba minus unarny */
            | value PLUS value
            | value MINUS value
            | value TIMES value
            | value DIV value
            | value MOD value

value:      identifier
            | num { $$ = codeGen->allocateConstant($1); } /* if it exists just return its address */

identifier:     pidentifier { Variable* var = codeGen->getVar(*$1);
                                if (var == nullptr && !error) {
                                    error = true;
                                    yyerror("Variable " + *$1 + " not defined");
                                 } else {
                                    $$ = var;
                                 }
                            }

%%

int yyerror (std::string s) {
    std::cerr << "Error: " << s << " in line " << yylineno << std::endl;
    return 0;
}

int main(int argc, char** argv) {
    // variable array

    std::shared_ptr<IOOperations> io = std::make_shared<IOOperations>(argc, argv);
    // read input file
    yyin = io->readCode();

    // check if file was read successfully
    if (yyin == nullptr) {
        return -1;
    }

    std::cout << "-------- ...Compiling... --------" << std::endl;

    yyparse();

    // error handling
    // write to file if no errors occurred
    codeGen->addInstruction("HALT");
    if (!error) {
        io->writeCode(codeGen->getCode());
        std::cout << "-------- Compilation successful --------" << std::endl;
    } else {
        std::cout << "-------- Compilation failed --------" << std::endl;
    }
    return 0;
}