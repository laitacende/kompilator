%{
    #include <iostream>
    #include <string>
    #include <memory>
    #include <fstream>

    #include "./inc/IOOperations.hpp"
    #include "./inc/CodeGenerator.hpp"
    #include "./inc/Symbol.hpp"
    #include "./inc/Cond.hpp"

    extern int yylineno;
    extern int yylex();
    extern FILE *yyin;

    int yyerror(std::string s);

    std::shared_ptr<MemoryData> dataController = std::make_shared<MemoryData>();
    std::shared_ptr<CodeGenerator> codeGen = std::make_shared<CodeGenerator>(dataController);

    std::vector<std::string> newSet;
    bool error = false;
    long long int line = 0;
    long long int lineRepeat = 0;
%}

%define parse.error verbose

%union types {
    std::string* pidentifier;
    long long int num;
    Variable* var;
    Cond* cond;
}

%start program
%token BEGIN_ /* conflict with macro BEGIN in flex */
%token END
%token VAR
%token WRITE
%token READ
%token ASSIGN
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token IF
%token THEN
%token ELSE
%token ENDIF
%token EQ
%token NEQ
%token GE
%token LE
%token LEQ
%token GEQ
%token WHILE
%token DO
%token ENDWHILE
%token REPEAT
%token UNTIL
%token <num> num
%token <pidentifier> pidentifier
%token ERROR

%type <var> value
%type <var> identifier
%type <var> expression
%type <cond> condition /* number of line of jump in code + type */
%%

program:    VAR declarations BEGIN_ commands END
            | BEGIN_ commands END

declarations: declarations',' pidentifier { Variable* v = codeGen->allocateVariable(*$3);
                                             if (nullptr == v) {
                                                error = true;
                                                yyerror("Redefinition of variable " + *$3);
                                             }
                                            }
              | pidentifier     { Variable* v = codeGen->allocateVariable(*$1);
                                    if (nullptr == v && !error) {
                                        error = true;
                                        yyerror("Redeclaration of variable " + *$1);
                                    }
                                }

commands:   commands command
            | command

command:    WRITE value';' { if (!codeGen->write($2) && !error) {
                                error = true;
                                yyerror("Variable " + $2->name +" is not initialized");
                              }
                            }

            | identifier ASSIGN expression';' {  codeGen->assignToVariable($1, $3); }

            | READ identifier';'    { if (!codeGen->read($2) && !error) {
                                        error = true;
                                      }
                                    }

            | IF condition THEN commands { line = codeGen->addInstruction("JUMP "); // omit else, edit later
                                            std::string instr = codeGen->getInstruction($2->index);
                                            instr = instr + std::to_string(codeGen->offset - $2->index);
                                            codeGen->changeInstruction($2->index, instr); // go to else
                                            if ($2->type == "EQ" || $2->type == "LE" || $2->type == "GE") {
                                                instr = codeGen->getInstruction($2->index - 1);
                                                instr = instr + std::to_string(codeGen->offset - $2->index + 1);
                                                codeGen->changeInstruction($2->index - 1, instr);
                                            }
                                          }
              ELSE commands ENDIF        { std::string instr = "JUMP " + std::to_string(codeGen->offset - line);
                                            codeGen->changeInstruction(line, instr); // edit instr from first block, jump adter else
                                         }

            | IF condition THEN commands ENDIF {    std::string instr = codeGen->getInstruction($2->index); /* if EQ there are two jumps */
                                                    instr = instr + std::to_string(codeGen->offset - $2->index);
                                                    codeGen->changeInstruction($2->index, instr);
                                                    if ($2->type == "EQ" || $2->type == "LE" || $2->type == "GE") {
                                                        instr = codeGen->getInstruction($2->index - 1);
                                                        instr = instr + std::to_string(codeGen->offset - $2->index + 1);
                                                        codeGen->changeInstruction($2->index - 1, instr);
                                                    }
                                                }

            | WHILE condition DO commands ENDWHILE  { std::string instr = codeGen->getInstruction($2->index); /* if EQ there are two jumps */
                                                      instr = instr + std::to_string((codeGen->offset - $2->index + 1));
                                                      codeGen->changeInstruction($2->index, instr);
                                                      if ($2->type == "EQ" || $2->type == "LE" || $2->type == "GE") {
                                                          instr = codeGen->getInstruction($2->index - 1);
                                                          instr = instr + std::to_string((codeGen->offset - $2->index + 2));
                                                          codeGen->changeInstruction($2->index - 1, instr);
                                                      }
                                                      //std::cout << codeGen->offset << std::endl;
                                                      codeGen->addInstruction("JUMP -" + std::to_string((codeGen->offset - $2->firstIndex + 1)));
                                                     }

            | REPEAT { lineRepeat = codeGen->offset; }
            commands UNTIL condition';'   {   std::string instr = codeGen->getInstruction($5->index); /* if EQ there are two jumps */
                                                instr = instr + std::to_string((-(codeGen->offset - lineRepeat) + 1));
                                                codeGen->changeInstruction($5->index, instr);
                                                if ($5->type == "EQ" || $5->type == "LE" || $5->type == "GE") {
                                                    instr = codeGen->getInstruction($5->index - 1);
                                                    instr = instr + std::to_string((-(codeGen->offset - lineRepeat) + 2));
                                                    codeGen->changeInstruction($5->index - 1, instr);
                                                }
                                                //std::cout << codeGen->offset << std::endl;

                                               // codeGen->addInstruction("JUMP -" + std::to_string((codeGen->offset - lineRepeat)));
                                           }


expression: value
            | value PLUS value { codeGen->add($1, $3); }
            | value MINUS value { codeGen->subtract($1, $3); }
            | value TIMES value { codeGen->multiply($1, $3); }
            | value DIV value   { codeGen->divide($1, $3); }
            | value MOD value   { codeGen->modulo($1, $3); }

condition:  value NEQ value { $$ = codeGen->evalNotEqual($1, $3); }
            | value EQ value { $$ = codeGen->evalEqual($1, $3); }
            | value LE value { $$ = codeGen->evalLess($1, $3); }
            | value GE value { $$ = codeGen->evalGreater($1, $3); }
            | value LEQ value { $$ = codeGen->evalLessEqual($1, $3); }
            | value GEQ value { $$ = codeGen->evalGreaterEqual($1, $3); }

value:      identifier { $$ = $1;
                         if ($1 != nullptr && !$1->isInit && !error) {
                            error = true;
                            yyerror("Variable " + $1->name + " not initialized");
                         }
                        }
            | num { $$ = codeGen->allocateConstant($1);  } /* if it exists just return its address */
            | '-' num { $$ = codeGen->allocateConstantNegate($2); }

identifier:     pidentifier { Variable* var = codeGen->getVar(*$1);
                                if (var == nullptr && !error) {
                                    error = true;
                                    yyerror("Variable " + *$1 + " not defined");
                                    $$ = nullptr;
                                 } else {
                                    $$ = var;
                                 }
                            }

%%

int yyerror (std::string s) {
    error = true;
    std::cerr << "Error: " << s << " in line " << yylineno << std::endl;
    return 0;
}

int main(int argc, char** argv) {
    // variable array

    std::shared_ptr<IOOperations> io = std::make_shared<IOOperations>(argc, argv);
    // read input file
    yyin = io->readCode();

    // check if file was read successfully
    if (yyin == nullptr) {
        return -1;
    }

    std::cout << "-------- ...Compiling... --------" << std::endl;

    yyparse();

    // error handling
    // write to file if no errors occurred
    codeGen->addInstruction("HALT");
    if (!error) {
        io->writeCode(codeGen->getCode());
        std::cout << "-------- Compilation successful --------" << std::endl;
    } else {
        std::cout << "-------- Compilation failed --------" << std::endl;
    }
    return 0;
}